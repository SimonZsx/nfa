// This module handles reliable message passing for remote communication.

#include <string>

#include "../bessport/packet.h"
#include "../bessport/pktbatch.h"

using std::string;
using bess::Packet;
using bess::PacketBatch;

// size of the send queue, equals to 4 batches
static constexpr int send_queue_size = 128;

// The threshold for doing an retransmission, if
// 3/4 of the send ring is occupied, we do an retransmission.
// We adjust next_send_ to send_ring_head_ and retransmit
// the content in the send ring from there.
static constexpr int retran_thresh = 128-32;

// size of the recv queue, equals to 4 batches
static constexpr int recv_queue_size = 128;

class reliable_p2p {

public:

  // The constructor should initialize
  // all the uninitialized private fields associated
  // with the ring buffers.
  reliable_p2p(uint64_t hex_dst_mac);

  // @msg_start_addr: the starting address of the message
  // to be sent as a packet. The message should be translated
  // in to the payload of one or several packets and placed them on
  // the send ring buffer
  // @msg_size: the size of the message to be sent.
  // @return_val: whether we successfully enqueue the message for sending
  // note that if the send ring can't hold the packets generated by the message
  // this function should return a false.
  inline bool enqueue_msg(char* msg_start_addr, int msg_size);

  // an overload of the previous function.
  // @pkt: The pkt argument is also a message to be sent. This is used during
  // replication.
  inline bool enqueue_msg(char* msg_start_addr, int msg_size, Packet* pkt);

  // @batch: The details of the PacketBatch is available at pktbatch.h
  // the caller of the send function should provide the batch variable
  // to the function. Inside send, you should extract message packets f
  // from the send_ring_buffer_ starting from next_send_. For each packet, you should append a
  // ethernet header and a sequential number. Then you should place these
  // packets to the batch variable.
  // If the packet is an ack message, then send function adjust send_ring_tail_
  // Notice:
  // The send function is regularly invoked to check for retransmission.
  // If the size of the send ring is larger than retran_thresh, we should perform
  // a retransmission by next_send_=send_ring_head_ and send from the next_send_
  void send(PacketBatch* batch);

  // @batch: the batch contains all the message packets sent to the recv.
  // The recv function should only enqueue the packet to the recv ring
  // if the sequential number of the packet is last_recv_seq_+1. And then
  // update the last_recv_seq_. The recv function discards any out of order
  // packets.
  // After filling in all the packets in the batch into the recv ring, the
  // recv function should examine from recv_ring_head_ to extract messages
  // For each extracted message, the recv function should directly call the
  // message handler of the receiver actor.
  void recv(PacketBatch* batch);

  // @batch: generate_acks function place an ack with last_recv_seq_ and send the
  // ack message back to the sender.
  void generate_acks(PacketBatch* batch);

private:

  // the destination mac address, encoded as
  // hex values in 6 bytes. This is used as a
  // key to identify the reliable_p2p object
  const uint64_t hex_dst_mac_;

  // The ring buffer for storing packets to send
  Packet* send_ring_buffer_[send_queue_size];

  // the head position of the send ring
  int send_ring_head_;

  // the tail position of the send ring
  int send_ring_tail_;

  // number of packets in the send ring
  int send_ring_pkts_;

  // the position for the start of the next send
  int next_send_;

  // current sequential number
  uint32_t cur_seq_num_;

  // The ring buffer for storing received packets
  Packet* recv_ring_buffer_[send_queue_size];

  // the head position of the send ring
  int recv_ring_head_;

  // the tail position of the send ring
  int recv_ring_tail_;

  // number of packets in the send ring
  int recv_ring_pkts_;

  // the sequential number of the last received packet
  int last_recv_seq_;
};
